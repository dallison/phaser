# Phaser User Guide

Phaser is a Google Protobuf compiler plugin that provides zero-copy protobuf messages
without the need for serialization.  This means that you can create and access protobuf
IDL messages directly in a memory buffer instead of creating objects from the heap
or from an arena.  Once created, messages may be transferred to another computer,
or sent over an IPC system without any further processing.

Protobuf's version compatibility is fully supported allowing you to use different
versions of messages interchangeably.  This allows you to store the binary messages
and later retrieve them with newer software, or to communicate with computers running
different software versions.

The wire-format for Phaser messages is not the same as serialized protobuf format,
but for compatibility with protobuf, Phaser supports full protobuf serialization.  This
is useful when storing messages in a format that is recognized by services such as
*BigQuery* where protobuf wire-format is required.

Other features include:

1. Target IDL is proto3, but proto2 is also supported
2. Message printing to std::ostream
3. Fixed and variable-sized buffers can be used
4. User-supplied metadata can be added to the message.
5. Full support for *google.protobuf.Any*
6. Enum printing and parsing
7. Message reflection
8. Presence masks
9. Bazel build
10. Modern C++17 with Google Abseil

## How Phaser works
Phaser works as a plugin for the Protocol Buffers compiler (protoc).  This means that protoc
does the parsing of the *.proto* files and hands off to Phaser to generate code.  Only
C++ output is supported.

To the programmer, the messages generated by Phaser look just like those generated by
the regular C++ protobuf backend, with a few enhancements and minor incompatibilities.  They
are generated as C++ classes with accessor functions for each field - with the same names
as those generated by protobuf. 

However, while protobuf creates a tree of allocated objects holding the message data, Phaser's
message classes do not store the actual field values directly, but rather the values are
stored in a separate buffer, directly in the wire-format.  The *source* messages (the C++
classes that the programmer sees) merely store information about where the actual data
is stored in the *binary* message held in the buffer.

So, when you set a field using the *set_* function, the data is placed in the *binary*
buffer using information held in the *source* class.  This makes the source classes very
lightweight, containing just metadata about the binary message.

When you read a field from a source class, the data is read from the binary message.  However,
this is not done directly since the binary message may be a different version from that
doing the reading (fields may be been added or changed).  Therefore, reading a field results
in the use of *field metadata* that is held in a small array inside the binary message.  This
allows the software to use newer or older version of messages, one of the mainstays of
protobuf's popularity.

## What's wrong with serialization?
It all depends on what you doing with the messages and what the messages look like.  For small
workloads it is perfectly fine to use the protobuf serialization method as the time taken
to perform the conversion to and from wire-format is negligible.  However, in some performance
critical applications (like robots or AVs), messages tend to contain large sensor data streams
and the serialization time can dominate the CPU, sometimes using up to 60% of the time.  A few years
ago, Google reckoned that serialization took 30% of the CPU time in their data centers.

If you can avoid serialization, at least for the messages that matter (sensor data or other large
messages) you can save all that CPU and get much better usage out of your embedded system running
your robot.

Also, most of the time, inside a robot, you are not using different versions of software
and therefore, the version compatibility provided by serialization is not needed.  This is
especially true when you use shared memory for Interprocess Communication (IPC) where processes
can access the same physical memory directly.  Serializing it into shared memory, just to deserialize
it again in the subscribers is just a waste of valuable compute cycles.

Another problem with serialization, or more accurately, deserialization is that unless you
are going to process all the messages you receive, you will be spending CPU cycles on
unnecessary work.  Many robotics applications don't process all of the messages they
receive over IPC and only take the most recent.  Any messages that are deserialized
and thrown away is wasted time.

## Zero-copy FTW
All programs that use protobuf operate in the same way: you create your messages in objects
allocated from the heap (or from an arena if you need it to go slightly faster), then you
serialize them into a buffer and send that buffer onward.  Creating your messages involves
calling setter functions to set the values.  Adding values to repeated fields involved pushing
them into a vector.  Creating message-valued fields involves allocating a new object and
setting its values.

This is all good, and serializing small messages is no biggie, but what if your message
contains a large repeated field of floating point numbers (think of a LIDAR scan) or a large
buffer (bytes field in protobuf parlance) containing an RGB camera image?  Your program will
spend a long time copying the values into place, then it will copy them again during your
serialization step.

With zero-copy, you have a facility that allows you to directly access the final location
for the data.  If you change your algorithm to take advantage of this direct access, you
can speed up the message creation by up to an order of magnitude.  So instead of
looping over a set of floating point values, adding each to a vector, you can get a pointer
to the start of the vector's memory and write directly to it.

Another common message pattern is a repeated field of messages.  In this case you create
a new object for each element, add it to the vector and fill them in.  With zero-copy
you can add a bunch of messages at once, performing only one allocation and then
fill all of them in.  A huge saving.

And, if your robotics nodes are processing only the most recent messages, or storing
messages in a history buffer, there is no time wasted in deserializing messages that
you won't use.

## Creating a message
In protobuf, you generally create messages on the local stack frame or from the heap. 
Submessages (fields whose type is a message) are allocated from the heap.

In Phaser, it's almost the same except you have to be aware of where the final
location for the data will reside.  It can be in a fixed size buffer allocated from
the heap or from an IPC system.  It can also be in a variable sized buffer allocated
from the heap.  The data stored in the buffer is referred to as the *binary* message.
The C++ class that represents the message is referred to as the *source* message and
can be on the local stack frame or anywhere you like.

When you build your Phaser messages, you have an option to add a C++ namespace
to the class name to distinguish it from a protobuf class of the same name.  This
allows you to intermix Phaser and protobuf messages.  Generally, this is a good
idea and I tend to choose the name "phaser" as the namespace.

### Message in a dynamic buffer.
The simplest way to create a Phaser message is the same as protobuf:

```c++
void Foo() {
  foo::bar::phaser::TestMessage msg;
  msg.set_x(1234);
  // ...
}
```

The above example creates a Phaser message of the type *TestMessage* on the local stack
frame.  The binary message will be held in a variable sized buffer allocated from the
heap.  The initial size of the buffer can be specified as an argument to the
constructor, but is optional with a default of 1024 bytes (if 1K is big enough, or twice the
required binary size if not) but will expand as necessary.

To get access to the buffer you can use the *Data()* and *Size()* functions, for
example:

```c++
void Foo() {
  foo::bar::phaser::TestMessage msg(4096);
  msg.set_x(1234);
  // ...
  SendMessage(msg.Data(), msg.Size());
}
```

For completeness, the default constructor for a message (for one on the stack) can also
be achieved using the function *CreateDynamicMutable*, which also allows you to
specify the initial buffer size (with a 1K default) to be allocated for the binary message from the
heap:

```c++
void Foo() {
  auto msg = foo::bar::phaser::TestMessage::CreateDynamicMutable(4096);
  msg.set_x(1234);
  // ...
}
```

### Message in a provided buffer.
If you are using an IPC system that provides shared memory buffers (like [Subspace](https://github.com/dallison/subspace)) you will want to create your message directly in the shared memory.  To do this, use the
static function *CreateMutable*, as follows:

```c++
void Foo(char* buffer, size_t size) {
  auto msg = foo::bar::phaser::TestMessage::CreateMutable(buffer, size);
  msg.set_x(1234);
  // ...
}
```

As before, the *Data()* and *Size()* functions are available to get the buffer (although you
probably already know the buffer's address).

If the buffer is fixed size and you attempt to write beyond the end of the buffer, the
program will abort to prevent memory overwrites.

It is also possible to provide a resize function to allow an IPC buffer to be resized
but this is outside of the scope of this discussion at this time as it depends a lot
on the abilities of the IPC system.

### Message received from elsewhere
The whole purpose of sending messages is to receive them in another location.  When you receive
a message you will generally get it in a read-only buffer.  To gain access to the received message
call the function *CreateReadonly*:

```c++
void Receive(const char* buffer, size_t buffer_size) {
  auto msg = foo::bar::phaser::TestMessage::CreateReadonly(buffer, size);
  int x = msg.x();
  // ...
}
```

The runtime access to fields in the message validates that nothing can go outside
of the buffer you pass to *CreateReadonly*.


## Setting and getting fields
Creating a message usually involves setting the values in its fields, and using one
will generally involve reading them.  The C++ class for a message is generated with 
setter and getter functions for each field, just like protobuf. 

## Primitive fields
For primitive fields, like an *int32* field, the following functions are generated:

```c++
  int32_t x() const;
  bool has_x() const;
  void clear_x();
  void set_x(int32_t value);
```

For a field that holds a message, different functions are generated.  For example,
if a field holds a message type *InnerMessage*, the following function exist:

```c++
  void clear_m();
  const InnerMessage& m() const;
  bool has_m() const ;
  InnerMessage* mutable_m();
```

String (and bytes) fields are similar except there is a special *allocate_*
function that allows you to allocate space in the binary message and obtain
its address.  This is to provide a way to get access to the underlying
buffer directly and can be used to speed everything up.  For example,
for a string field called *s* we have the following functions:

```c++
  std::string_view s() const;
  bool has_s() const;
  void clear_s();
  template <typename Str>
  void set_s(Str value);
  absl::Span<char> allocate_s(size_t len);
```

### Repeated fields
Repeated fields are implemented as
contiguous vectors.  In addition to the regular protobuf accessors, additional
functions are generated to take advantage of the fact that you have access to
the final location of the data.  For a repeated int32 field (called *vi32*), we have the
following functions:

```c++
  int32_t vi32(size_t index) const;
  size_t vi32_size() const;
  void clear_vi32();
  void reserve_vi32(size_t num);
  void resize_vi32(size_t num);
  void add_vi32(int32_t value);
  void set_vi32(size_t index, int32_t value);
  absl::Span<int32_t> vi32_as_mutable_span();
  absl::Span<const int32_t> vi32_as_span() const;
  const ::phaser::PrimitiveVectorField<int32_t, false, false, true>& vi32() const;
```

Some of these are the same as protobuf but others, like *resize_vi32*, *reserve_vi32*
and the *as_span* functions are specific to Phaser and allow you to access the
underlying binary buffer.

The *PrimitiveVectorField* class is similar to protobuf's *RepeatedField* class and will
be discussed in a later section.

Repeated string fields are pretty obvious:

```c++
  std::string_view vstr(size_t index) const;
  size_t vstr_size() const;
  void clear_vstr();
  void reserve_vstr(size_t num);
  void resize_vstr(size_t num);
  template <typename Str>
  void add_vstr(Str value);
  template <typename Str>
  void set_vstr(size_t index, Str value);
  const ::phaser::StringVectorField& vstr() const;
```

Repeated message fields are also as expected.  For a repeated *InnerMessage*
field:

```c++
  size_t vm_size() const;
  void clear_vm();
  const InnerMessage& vm(size_t index) const;
  InnerMessage* mutable_vm(size_t index);
  InnerMessage* add_vm();
  const ::phaser::MessageVectorField<InnerMessage>& vm() const;
  void reserve_vm(size_t num);
  void resize_vm(size_t num);
  std::vector<InnerMessage*> allocate_vm(size_t n);
```

The *resize* and *reserve* functions operate similarly to *std::vector*.  The
*allocate* function allocates *n* messages in a block and provides pointers
to the source messages allocated.  This is a performance enhancement to allow
faster creation of a common pattern in protobuf message.

### Oneof fields
A *oneof* field is a discriminated union that holds only one of a number of
fields at any time (or none of them I guess).  For example, to define
a *oneof* inside a message, you do this:

```pb
message Foo {
  int32 x = 1;
  oneof request {
    InitRequest init = 2;
    TermRequest term = 3;
  }
}
```

This defines a union called *request* that can have either *init* or *term*, both
of which are message types.  Like protobuf, Phaser generates each of the fields
exactly as if they are outside of the *oneof*, and also provides a function to
determine the discriminator:

```c++
  int request_case() const;
```

The *_case* function returns the *number* of the field that is present in the
*oneof*, or 0 if none are present.


### Any fields
The *proto3* Protocol Buffers IDL variant provides a type called *google.protobuf.Any* that
can be used to hold any message type.  This is kind of like a `void*` in C with a string
that tells you what type it is.  Take a gander at [this](https://protobuf.dev/programming-guides/proto3/#any) for
details on how it works.

Phaser supports the *google.protobuf.Any* type slightly differently from the
way regular protobuf does.  Since Phaser is zero-copy, the *value* field of the
*google.protobuf.Any* message doesn't contain a serialized message, but rather contains
an actual binary message.  You don't need to call the *PackFrom* and *UnpackTo* functions
to access it, but instead you have direct access to it.  *PackFrom* and *UnpackTo* are
provided but result in copies of the message being made, rather than serializing and
deserializing the message.

The facilities provided for *Any* support are:

```c++
  template <typename T> bool PackFrom(const T &msg);
  template <typename T> absl::Status PackFromOrStatus(const T &msg);
  template <typename T> bool UnpackTo(T *msg) const;
  template <typename T> absl::Status UnpackToOrStatus(T *msg) const;
  template <typename T> bool Is() const;
  template <typename T> const T As() const;
  template <typename T> T MutableAny();
```

The *...OrStatus* functions are provided to allow you to get more information than
a simple *bool* can provide if things go wrong.  

#### Packing and unpacking Any
You should use the *Is* template function to check what type is in the *value* field.

*PackFrom* performs a copy of the input message into the *value* field of the *Any* field, and 
sets the *type_url* field to the message type.  The type URL always has the prefix *type.googleapis.com/*.

*UnpackTo* also performs a copy of the message into its argument.

#### Direct access
Since there is no serialization in Phaser, you can get direct access to the message stored
in the *value* field.  The *As* template gives you a const message that can be accessed
directly.  It does not check that the message is of the given type, so make sure to call
*Is* before.

The *MutableAny* function creates a mutable message of type *T* in the *value* field and sets
the *type_url*.  You can then create the message as you would do normally.

## Serialization and deserialization
Phaser doesn't do serialization, but protobuf does.  In order to give you a way to convert
from Phaser wire-format to protobuf, some transcoding serialiation functions are provided.
These are:

```c++
  size_t ByteSizeLong() const;
  int ByteSize() const;
  bool SerializeToArray(char* array, size_t size) const;
  bool ParseFromArray(const char* array, size_t size);
  bool SerializeToString(std::string* str) const;
  std::string SerializeAsString() const;
  bool ParseFromString(const std::string& str);

```

If you familiar with protobuf, you will recognize these and similar to those
provided by the regular protobuf messages.  Protobuf provides others (like
*ZeroCopyStream*) but those aren't provided by Phaser.

## Cloning and copying
Like protobuf, Phaser provides a *CopyFrom* method to copy messages.

## The Phaser Bank

## Reflection

