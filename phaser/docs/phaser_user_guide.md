# Phaser User Guide

Phaser is a Google Protobuf compiler plugin that provides zero-copy protobuf messages
without the need for serialization.  This means that you can create and access protobuf
IDL messages directly in a memory buffer instead of creating objects from the heap
or from an arena.  Once created, messages may be transferred to another computer,
or sent over an IPC system without any further processing.

Protobuf's version compatibility is fully supported allowing you to use different
versions of messages interchangeably.  This allows you to store the binary messages
and later retrieve them with newer software, or to communicate with computers running
different software versions.

The wire-format for Phaser messages is not the same as serialized protobuf format,
but for compatibility with protobuf, Phaser supports full protobuf serialization.  This
is useful when storing messages in a format that is recognized by services such as
*BigQuery* where protobuf wire-format is required.

Other features include:

1. Target IDL is proto3, but proto2 is also supported
2. Message printing to std::ostream
3. Fixed and variable-sized buffers can be used
4. User-supplied metadata can be added to the message.
5. Full support for *google.protobuf.Any*
6. Enum printing and parsing
7. Message reflection
8. Presence masks
9. Bazel build
10. Modern C++17 with Google Abseil

## How Phaser works
Phaser works as a plugin for the Protocol Buffers compiler (protoc).  This means that protoc
does the parsing of the *.proto* files and hands off to Phaser to generate code.  Only
C++ output is supported.

To the programmer, the messages generated by Phaser look just like those generated by
the regular C++ protobuf backend, with a few enhancements and minor incompatibilities.  They
are generated as C++ classes with accessor functions for each field - with the same names
as those generated by protobuf. 

However, while protobuf creates a tree of allocated objects holding the message data, Phaser's
message classes do not store the actual field values directly, but rather the values are
stored in a separate buffer, directly in the wire-format.  The *source* messages (the C++
classes that the programmer sees) merely store information about where the actual data
is stored in the *binary* message held in the buffer.

So, when you set a field using the *set_* function, the data is placed in the *binary*
buffer using information held in the *source* class.  This makes the source classes very
lightweight, containing just metadata about the binary message.

When you read a field from a source class, the data is read from the binary message.  However,
this is not done directly since the binary message may be a different version from that
doing the reading (fields may be been added or changed).  Therefore, reading a field results
in the use of *field metadata* that is held in a small array inside the binary message.  This
allows the software to use newer or older version of messages, one of the mainstays of
protobuf's popularity.

## What's wrong with serialization?
It all depends on what you doing with the messages and what the messages look like.  For small
workloads it is perfectly fine to use the protobuf serialization method as the time taken
to perform the conversion to and from wire-format is negligible.  However, in some performance
critical applications (like robots or AVs), messages tend to contain large sensor data streams
and the serialization time can dominate the CPU, sometimes using up to 60% of the time.  A few years
ago, Google reckoned that serialization took 30% of the CPU time in their data centers.

If you can avoid serialization, at least for the messages that matter (sensor data or other large
messages) you can save all that CPU and get much better usage out of your embedded system running
your robot.

Also, most of the time, inside a robot, you are not using different versions of software
and therefore, the version compatibility provided by serialization is not needed.  This is
especially true when you use shared memory for Interprocess Communication (IPC) where processes
can access the same physical memory directly.  Serializing it into shared memory, just to deserialize
it again in the subscribers is just a waste of valuable compute cycles.

Another problem with serialization, or more accurately, deserialization is that unless you
are going to process all the messages you receive, you will be spending CPU cycles on
unnecessary work.  Many robotics applications don't process all of the messages they
receive over IPC and only take the most recent.  Any messages that are deserialized
and thrown away is wasted time.

## Zero-copy FTW
All programs that use protobuf operate in the same way: you create your messages in objects
allocated from the heap (or from an arena if you need it to go slightly faster), then you
serialize them into a buffer and send that buffer onward.  Creating your messages involves
calling setter functions to set the values.  Adding values to repeated fields involved pushing
them into a vector.  Creating message-valued fields involves allocating a new object and
setting its values.

This is all good, and serializing small messages is no biggie, but what if your message
contains a large repeated field of floating point numbers (think of a LIDAR scan) or a large
buffer (bytes field in protobuf parlance) containing an RGB camera image?  Your program will
spend a long time copying the values into place, then it will copy them again during your
serialization step.

With zero-copy, you have a facility that allows you to directly access the final location
for the data.  If you change your algorithm to take advantage of this direct access, you
can speed up the message creation by up to an order of magnitude.  So instead of
looping over a set of floating point values, adding each to a vector, you can get a pointer
to the start of the vector's memory and write directly to it.

Another common message pattern is a repeated field of messages.  In this case you create
a new object for each element, add it to the vector and fill them in.  With zero-copy
you can add a bunch of messages at once, performing only one allocation and then
fill all of them in.  A huge saving.

And, if your robotics nodes are processing only the most recent messages, or storing
messages in a history buffer, there is no time wasted in deserializing messages that
you won't use.

## Creating a message
In protobuf, you generally create messages on the local stack frame or from the heap. 
Submessages (fields whose type is a message) are allocated from the heap.

In Phaser, it's almost the same except you have to be aware of where the final
location for the data will reside.  It can be in a fixed size buffer allocated from
the heap or from an IPC system.  It can also be in a variable sized buffer allocated
from the heap.  The data stored in the buffer is referred to as the *binary* message.
The C++ class that represents the message is referred to as the *source* message and
can be on the local stack frame or anywhere you like.

When you build your Phaser messages, you have an option to add a C++ namespace
to the class name to distinguish it from a protobuf class of the same name.  This
allows you to intermix Phaser and protobuf messages.  Generally, this is a good
idea and I tend to choose the name "phaser" as the namespace.

### What exactly is a message?
In Phaser a message is a generated class derived from a C++ class of type `::phaser::Message`.  
This base class contains the following:

```c++
struct Message {
  Message() = default;
  Message(std::shared_ptr<MessageRuntime> rt, ::toolbelt::BufferOffset start)
      : runtime(rt), absolute_binary_offset(start) {}
  virtual ~Message() = default;

  virtual const MessageInfo *GetMessageInfo() const { return nullptr; }
  virtual std::string GetName() const { return "Message"; }
  virtual std::string GetFullName() const { return "phaser.Message"; }
  virtual void Clear() {}
  virtual void CopyFrom(const Message &src) {}

  std::shared_ptr<MessageRuntime> runtime;
  ::toolbelt::BufferOffset absolute_binary_offset;
};
```

The derived message classes contain the actual fields of the message along
with accessor functions.  It is designed to be as close to protobuf as possible
to avoid having to learn new classes if you are familar with protobuf.

The virtual functions are overridden by the derived classes.

The member `absolute_binary_offset` is the offset of the message into 
the `PayloadBuffer` (see below).

The member `runtime` is a pointer to the following struct:

```c++
// Each message contains a std::shared_ptr to one of these, allocated from
// the heap.  This is used when creating a message in the payload buffer
// so that we know where the metadata for each message is stored.  The
// metadata offset is held in the message header.
struct MessageRuntime {
  MessageRuntime(::toolbelt::PayloadBuffer *p) : pb(p) {}
  MessageRuntime(::toolbelt::PayloadBuffer *p, size_t size)
      : pb(p), buffer_size(size) {}
  virtual ~MessageRuntime() = default;
  ::toolbelt::PayloadBuffer *pb;

  // This is the size of the buffer.  If it is zero, the size is inside
  // the payload buffer.  If it's non-zero, it's the size of the received
  // buffer.  We can't rely on the size inside the payload buffer if we
  // are looking at received data (someone could set it to anything and we
  // have no way to check it's valid).
  size_t buffer_size = 0;
};

```
The members of this are:

1. `pb`: a pointer to a `PayloadBuffer` object that holds the actual binary for the message data
2. `buffer_size`: the size of the buffer if it was received

The `PayloadBuffer` is part of my [C++ Toolbelt library](https://github.com/dallison/cpp_toolbelt) and
provides a relocatable heap (malloc/free/realloc) inside a variable or fixed buffer.  It
holds the binary values for all fields in the message in a relocatable form.  Generally,
you won't have to concern yourself about the `PayloadBuffer`.


### Creating a message in a dynamic buffer.
The simplest way to create a Phaser message is the same as protobuf:

```c++
void Foo() {
  foo::bar::phaser::TestMessage msg;
  msg.set_x(1234);
  // ...
}
```

The above example creates a Phaser message of the type *TestMessage* on the local stack
frame.  The binary message will be held in a variable sized buffer allocated from the
heap.  The initial size of the buffer can be specified as an argument to the
constructor, but is optional with a default of 1024 bytes (if 1K is big enough, or twice the
required binary size if not) but will expand as necessary.

To get access to the buffer you can use the *Data()* and *Size()* functions, for
example:

```c++
void Foo() {
  foo::bar::phaser::TestMessage msg(4096);
  msg.set_x(1234);
  // ...
  SendMessage(msg.Data(), msg.Size());
}
```

For completeness, the default constructor for a message (for one on the stack) can also
be achieved using the function *CreateDynamicMutable*, which also allows you to
specify the initial buffer size (with a 1K default) to be allocated for the binary message from the
heap:

```c++
void Foo() {
  auto msg = foo::bar::phaser::TestMessage::CreateDynamicMutable(4096);
  msg.set_x(1234);
  // ...
}
```

### Creating a message in a provided buffer.
If you are using an IPC system that provides shared memory buffers (like [Subspace](https://github.com/dallison/subspace)) you will want to create your message directly in the shared memory.  To do this, use the
static function *CreateMutable*, as follows:

```c++
void Foo(char* buffer, size_t size) {
  auto msg = foo::bar::phaser::TestMessage::CreateMutable(buffer, size);
  msg.set_x(1234);
  // ...
}
```

As before, the *Data()* and *Size()* functions are available to get the buffer (although you
probably already know the buffer's address).

If the buffer is fixed size and you attempt to write beyond the end of the buffer, the
program will abort to prevent memory overwrites.

It is also possible to provide a resize function to allow an IPC buffer to be resized
but this is outside of the scope of this discussion at this time as it depends a lot
on the abilities of the IPC system.

### Message received from elsewhere
The whole purpose of sending messages is to receive them in another location.  When you receive
a message you will generally get it in a read-only buffer.  To gain access to the received message
call the function *CreateReadonly*:

```c++
void Receive(const char* buffer, size_t buffer_size) {
  auto msg = foo::bar::phaser::TestMessage::CreateReadonly(buffer, size);
  int x = msg.x();
  // ...
}
```

The runtime access to fields in the message validates that nothing can go outside
of the buffer you pass to *CreateReadonly*.


## Setting and getting fields
Creating a message usually involves setting the values in its fields, and using one
will generally involve reading them.  The C++ class for a message is generated with 
setter and getter functions for each field, just like protobuf. 

## Primitive fields
For primitive fields, like an *int32* field, the following functions are generated:

```c++
  int32_t x() const;
  bool has_x() const;
  void clear_x();
  void set_x(int32_t value);
```

For a field that holds a message, different functions are generated.  For example,
if a field holds a message type *InnerMessage*, the following function exist:

```c++
  void clear_m();
  const InnerMessage& m() const;
  bool has_m() const ;
  InnerMessage* mutable_m();
```

String (and bytes) fields are similar except there is a special *allocate_*
function that allows you to allocate space in the binary message and obtain
its address.  This is to provide a way to get access to the underlying
buffer directly and can be used to speed everything up.  For example,
for a string field called *s* we have the following functions:

```c++
  std::string_view s() const;
  bool has_s() const;
  void clear_s();
  template <typename Str>
  void set_s(Str value);
  absl::Span<char> allocate_s(size_t len);
```

### Repeated fields
Repeated fields are implemented as
contiguous vectors.  In addition to the regular protobuf accessors, additional
functions are generated to take advantage of the fact that you have access to
the final location of the data.  For a repeated int32 field (called *vi32*), we have the
following functions:

```c++
  int32_t vi32(size_t index) const;
  size_t vi32_size() const;
  void clear_vi32();
  void reserve_vi32(size_t num);
  void resize_vi32(size_t num);
  void add_vi32(int32_t value);
  void set_vi32(size_t index, int32_t value);
  absl::Span<int32_t> vi32_as_mutable_span();
  absl::Span<const int32_t> vi32_as_span() const;
  const ::phaser::PrimitiveVectorField<int32_t, false, false, true>& vi32() const;
```

Some of these are the same as protobuf but others, like *resize_vi32*, *reserve_vi32*
and the *as_span* functions are specific to Phaser and allow you to access the
underlying binary buffer.

The *PrimitiveVectorField* class is similar to protobuf's *RepeatedField* class and will
be discussed in a later section.

Repeated string fields are pretty obvious:

```c++
  std::string_view vstr(size_t index) const;
  size_t vstr_size() const;
  void clear_vstr();
  void reserve_vstr(size_t num);
  void resize_vstr(size_t num);
  template <typename Str>
  void add_vstr(Str value);
  template <typename Str>
  void set_vstr(size_t index, Str value);
  const ::phaser::StringVectorField& vstr() const;
```

Repeated message fields are also as expected.  For a repeated *InnerMessage*
field:

```c++
  size_t vm_size() const;
  void clear_vm();
  const InnerMessage& vm(size_t index) const;
  InnerMessage* mutable_vm(size_t index);
  InnerMessage* add_vm();
  const ::phaser::MessageVectorField<InnerMessage>& vm() const;
  void reserve_vm(size_t num);
  void resize_vm(size_t num);
  std::vector<InnerMessage*> allocate_vm(size_t n);
```

The *resize* and *reserve* functions operate similarly to *std::vector*.  The
*allocate* function allocates *n* messages in a block and provides pointers
to the source messages allocated.  This is a performance enhancement to allow
faster creation of a common pattern in protobuf message.

### Oneof fields
A *oneof* field is a discriminated union that holds only one of a number of
fields at any time (or none of them I guess).  For example, to define
a *oneof* inside a message, you do this:

```pb
message Foo {
  int32 x = 1;
  oneof request {
    InitRequest init = 2;
    TermRequest term = 3;
  }
}
```

This defines a union called *request* that can have either *init* or *term*, both
of which are message types.  Like protobuf, Phaser generates each of the fields
exactly as if they are outside of the *oneof*, and also provides a function to
determine the discriminator:

```c++
  int request_case() const;
```

The *_case* function returns the *number* of the field that is present in the
*oneof*, or 0 if none are present.


### Any fields
The *proto3* Protocol Buffers IDL variant provides a type called *google.protobuf.Any* that
can be used to hold any message type.  This is kind of like a `void*` in C with a string
that tells you what type it is.  Take a gander at [this](https://protobuf.dev/programming-guides/proto3/#any) for
details on how it works.

Phaser supports the *google.protobuf.Any* type slightly differently from the
way regular protobuf does.  Since Phaser is zero-copy, the *value* field of the
*google.protobuf.Any* message doesn't contain a serialized message, but rather contains
an actual binary message.  You don't need to call the *PackFrom* and *UnpackTo* functions
to access it, but instead you have direct access to it.  *PackFrom* and *UnpackTo* are
provided but result in copies of the message being made, rather than serializing and
deserializing the message.

The facilities provided for *Any* support are:

```c++
  template <typename T> bool PackFrom(const T &msg);
  template <typename T> absl::Status PackFromOrStatus(const T &msg);
  template <typename T> bool UnpackTo(T *msg) const;
  template <typename T> absl::Status UnpackToOrStatus(T *msg) const;
  template <typename T> bool Is() const;
  template <typename T> const T As() const;
  template <typename T> T MutableAny();
```

The *...OrStatus* functions are provided to allow you to get more information than
a simple *bool* can provide if things go wrong.  

#### Packing and unpacking Any
You should use the *Is* template function to check what type is in the *value* field.

*PackFrom* performs a copy of the input message into the *value* field of the *Any* field, and 
sets the *type_url* field to the message type.  The type URL always has the prefix *type.googleapis.com/*.

*UnpackTo* also performs a copy of the message into its argument.

#### Direct access
Since there is no serialization in Phaser, you can get direct access to the message stored
in the *value* field.  The *As* template gives you a const message that can be accessed
directly.  It does not check that the message is of the given type, so make sure to call
*Is* before.

The *MutableAny* function creates a mutable message of type *T* in the *value* field and sets
the *type_url*.  You can then create the message as you would do normally.

## Serialization and deserialization
Phaser doesn't do serialization, but protobuf does.  In order to give you a way to convert
from Phaser wire-format to protobuf, some transcoding serialiation functions are provided.
These are:

```c++
  size_t ByteSizeLong() const;
  int ByteSize() const;
  bool SerializeToArray(char* array, size_t size) const;
  bool ParseFromArray(const char* array, size_t size);
  bool SerializeToString(std::string* str) const;
  std::string SerializeAsString() const;
  bool ParseFromString(const std::string& str);

```

If you familiar with protobuf, you will recognize these and similar to those
provided by the regular protobuf messages.  Protobuf provides others (like
*ZeroCopyStream*) but those aren't provided by Phaser.

## Cloning and copying
Like protobuf, Phaser provides a *CopyFrom* method to copy messages.

## The Phaser Bank
A significant feature that is missing from protobuf implementations (that I
am aware of anyway) is the ability to do things with messages given only their
message type name.  Most people end up creating a database of type name versus
message descriptor and use reflection to handle this.

Phaser has a builtin feature called the `Phaser Bank`, which, as its name suggest
is a bank of Phaser messages, indexed by message name.  This allows you to manipulate
Phaser messages if you just know the message name and nothing else.  The ultimate in
type-erasure.

The functions provided by the the *PhaserBank* are all free functions in the *::phaser*
namespace and are:

```c++
absl::StatusOr<BankInfo *> GetPhaserBankInfo(std::string message_type);

void PhaserBankRegisterMessage(const std::string &name, const BankInfo &info);

absl::Status PhaserStreamTo(const std::string &message_type, const Message &msg,
                            std::ostream &os, int indent);
absl::StatusOr<std::string>
PhaserBankDebugString(const std::string &message_type, const Message &msg);

absl::Status PhaserBankSerializeToBuffer(const std::string &message_type,
                                         const Message &msg,
                                         ProtoBuffer &buffer);
absl::Status PhaserBankDeserializeFromBuffer(const std::string &message_type,
                                             Message &msg, ProtoBuffer &buffer);
absl::StatusOr<size_t> PhaserBankSerializedSize(const std::string &message_type,
                                                const Message &msg);

absl::StatusOr<Message *>
PhaserBankAllocateAtOffset(const std::string &message_type,
                           std::shared_ptr<::phaser::MessageRuntime> runtime,
                           toolbelt::BufferOffset offset);

template <typename T>
absl::StatusOr<std::pair<T *, toolbelt::BufferOffset>>
PhaserBankAllocate(const std::string &message_type,
                   std::shared_ptr<::phaser::MessageRuntime> runtime);

template <>
absl::StatusOr<std::pair<Message *, toolbelt::BufferOffset>>
PhaserBankAllocate(const std::string &message_type,
                   std::shared_ptr<::phaser::MessageRuntime> runtime);              

absl::Status PhaserBankClear(const std::string &message_type, Message &msg);

absl::Status PhaserBankCopy(const std::string &message_type, const Message &src,
                            Message &dst);

absl::StatusOr<const Message *>
PhaserBankMakeExisting(const std::string &message_type,
                       std::shared_ptr<::phaser::MessageRuntime> runtime,
                       const void *data);

absl::StatusOr<size_t> PhaserBankBinarySize(const std::string &message_type);

absl::StatusOr<const MessageInfo *>
PhaserBankMessageInfo(const std::string &message_type);

absl::StatusOr<bool> PhaserBankHasField(const std::string &message_type,
                                        const Message &msg, int number);

template <typename Field>
absl::StatusOr<Field *>
PhaserBankGetFieldByName(const std::string &message_type, Message &msg,
                         const std::string &name);

template <typename Field>
absl::StatusOr<Field *>
PhaserBankGetFieldByNumber(const std::string &message_type, Message &msg,
                           int number);
```

All the functions take the message type name and return an Abseil Status or
StatusOr.

For this to work, the Phaser message library for the message must be linked
into the executable as the PhaserBank is built by static initializers.

### Getting the information for a message given its name
The `GetPhaserBankInfo` function looks up the information for a message.  This gives
access to the `BankInfo` object for the message.  The *BankInfo* is like this:

```c++
struct BankInfo {
  void (*stream_to)(const Message &msg, std::ostream &os, int indent);
  absl::Status (*serialize_to_buffer)(const Message &msg, ProtoBuffer &buffer);
  absl::Status (*deserialize_from_buffer)(Message &msg, ProtoBuffer &buffer);
  size_t (*serialized_size)(const Message &msg);
  Message *(*allocate_at_offset)(
      std::shared_ptr<::phaser::MessageRuntime> runtime,
      toolbelt::BufferOffset offset);
  void (*clear)(Message &msg);
  absl::Status (*copy)(const Message &src, Message &dst);
  const Message *(*make_existing)(
      std::shared_ptr<::phaser::MessageRuntime> runtime, const void *data);
  size_t (*binary_size)();
  const MessageInfo *(*message_info)();
  bool (*has_field)(const Message &msg, int number);
  void *(*get_field_by_name)(Message &msg, const std::string &name);
  void *(*get_field_by_number)(Message &msg, int number);
};
```

The function pointers are populated for each of the messages generated by Phaser and as
long as the message library is linked in, it will be available.

You can also use the `PhaserBankMessageInfo` function to get reflection data for the message.  I'll
describe this in the section on message reflection.

### Protobuf transcoding
You can serialize and deserialize Phaser messages to and from protobuf wireformat using the 
`PhaserBankSerializeToBuffer`, `PhaserBankDeserializeFromBuffer` and `PhaserBankSerializedSize`
functions.  The serialization and deserialization use a class called `::phaser::ProtoBuffer`
to hold the binary data.  This is defined in the file `phaser/runtime/wireformat.h` and provides
a dynamically (or statically) sized byte buffer.  It's pretty easy to follow.

### Streaming and DebugString
You can stream a message to `std::ostream` using the `PhaserStreamTo` function.  If you want this
in a string there's the `PhaserBankDebugString` function to do that for you.

### Allocating messages
To allocate a new mutable message in a previously allocated binary buffer, you can call
`PhaserBankAllocate`.  This takes a message type name and a pointer to the `MessageRuntime`
class that is part of every message.  There is a general template that can be used when
you know the message type, and a specialized template for when you just want a pointer
to the `Message` base class.  The result is a pair containing a pointer to the source
message (allocated using new) and the absolute offset into the buffer of the location
of the binary message.

For example, to set the field `m` of a message to one allocated from PhaserBank:

```c++
  TestMessage msg;
  auto status =
      ::phaser::PhaserBankAllocate<InnerMessage>("foo.bar.InnerMessage", msg.runtime);
  // Check status here.
  auto[inner, offset] = *status;
  msg.set_m(offset);
  inner->set_str("Inner message");
```

There is also a very specialized function `PhaserBankAllocateAtOffset` that is used by the
*google.protobuf.Any* handler to set the message in the Any's *value* field.

If you want to allocate a message from existing data, such as data received over
the network, you can use `PhaserBankMakeExisting`.  This is pretty specialized and
is used by the Any handler.

### Clearing and copying
The functions `PhaserBankClear` and `PhaserBankCopy` allow you to clear the contents of
a message or copy it to another message.

### Reflection
PhaserBank allows you to examine the contents of messages without knowing the message
type.  You can:

1. See if a field is present in the message
2. Look up a field in a message by number or name

The result of looking up a field is an instance of an internal field class.  In order
to use these, please see the files `runtime/fields.h`, `runtime/union.h` and `runtime/vectors.h`.
It's beyond the scope of this user guide to explain these, but I will provide further
documentation to cover them.

However, as an example, here's how to access an int32 field called `x` with number 100.

```c++
  absl::StatusOr<bool> has_x =
      ::phaser::PhaserBankHasField("foo.bar.TestMessage", msg, x_number);

  absl::StatusOr<::phaser::Int32Field<> *> x =
      ::phaser::PhaserBankGetFieldByNumber<::phaser::Int32Field<>>(
          "foo.bar.TestMessage", msg, 100);
  int x_value = (*x)->Get();
```

The class `phaser:;Int32Field` is in `runtime/fields.h`.

To access a repeated field:

```c++
 auto vi32 = ::phaser::PhaserBankGetFieldByNumber<
      ::phaser::PrimitiveVectorField<int32_t>>("foo.bar.TestMessage", msg, 104);
```

## Message information
Protobuf provides various types describing the details of a message.  These are known
as `Descriptors`.  Phaser provides similar data structures.  There are both a static
and a virtual function to get the message information from a message:

1. `GetMessageInfo()` - virtual function on `::phaser::Message`
2. `GetMessageInfoStatic` - static function generated by the compiler for the actual message

The result is a const pointer to `::phaser::MessageInfo`.  This is a class that contains
maps for all the fields in the message.  It is defined in `runtime/message.h` as:

```c++
struct MessageInfo {
  std::string full_name;
  absl::flat_hash_map<std::string, std::shared_ptr<FieldInfo>> fields_by_name;
  absl::flat_hash_map<int, std::shared_ptr<FieldInfo>> fields_by_number;
  std::vector<std::shared_ptr<FieldInfo>> fields_in_order;
};
```
The members are:

1. `full_name`: the full name (with package) of the message
2. `fields_by_name`: a map of field name vs field information
3. `fields_by_number`: mapping of field number vs information
4. `fields_in_order`: all the fields in the message in the order declared in the .proto file

The field information is a base class and two derived classes.  The base class is:

```c++
enum class FieldType {
  kFieldInt32,
  kFieldInt64,
  kFieldUInt32,
  kFieldUInt64,
  kFieldString,
  kFieldMessage,
  kFieldBytes,
  kFieldFloat,
  kFieldDouble,
  kFieldBool,
  kFieldEnum,
  kFieldOneof,
};

struct FieldInfo {
  FieldInfo(const std::string &n, FieldType t, int num, off_t off)
      : name(n), type(t), number(num), offset(off) {}
  std::string name;
  FieldType type;
  int number;
  off_t offset; // Offset into source message (not binary).
};

```

There is a derived class for all primitive fields (non-oneof fields):

```c++
struct PrimitiveFieldInfo : public FieldInfo {
  PrimitiveFieldInfo(const std::string &n, FieldType t, int num, off_t off,
                     bool f = false, bool s = false, bool r = false,
                     bool p = false)
      : FieldInfo(n, t, num, off), is_fixed(f), is_repeated(r), is_packed(p) {}
  PrimitiveFieldInfo(const std::string &n, FieldType t, int num, off_t off,
                     const std::string &m, bool r = false, bool p = false)
      : FieldInfo(n, t, num, off), is_repeated(r), is_packed(p),
        message_or_enum_name(m) {}

  bool is_fixed = false;
  bool is_signed = false;
  bool is_repeated = false;
  bool is_packed = true;
  std::optional<std::string> message_or_enum_name;
};
```

This is used for both singular and repeated fields.

For `oneof` fields, a derived class describes the set of fields within the
discriminated union:

```c++
struct UnionFieldInfo : public PrimitiveFieldInfo {
  UnionFieldInfo(const std::string &n, FieldType t, int num, off_t off, int i,
                 const std::string &m)
      : PrimitiveFieldInfo(n, t, num, off, m), id(i) {}
  UnionFieldInfo(const std::string &n, FieldType t, int num, off_t off, int i,
                 bool f = false, bool s = false)
      : PrimitiveFieldInfo(n, t, num, off, f, s), id(i) {}
  int id; // Field id within union.
};

struct UnionInfo : public FieldInfo {
  UnionInfo(const std::string &n, off_t off)
      : FieldInfo(n, FieldType::kFieldOneof, 0, off) {}
  std::vector<std::shared_ptr<UnionFieldInfo>> fields_in_order;
};

```

The union field (a.k.a. oneof) has a vector of `UnionFieldInfo` objects, each of which
is a primitive field.  Oneofs can't have repeated fields.  The `id` member of
`UnionFieldInfo` is a zero-based number representing the position in the `fields_in_order`
vector and is used to select the index into the `std::tuple` held in the internal
union field in a message (I'll show how to use this in a details document).


