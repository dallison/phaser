# Phaser User Guide

Phaser is a Google Protobuf compiler plugin that provides zero-copy protobuf messages
without the need for serialization.  This means that you can create and access protobuf
IDL messages directly in a memory buffer instead of creating objects from the heap
or from an arena.  Once created, messages may be transferred to another computer,
or sent over an IPC system without any further processing.

Protobuf's version compatibility is fully supported allowing you to use different
versions of messages interchangeably.  This allows you to store the binary messages
and later retrieve them with newer software, or to communicate with computers running
different software versions.

The wire-format for Phaser messages is not the same as serialized protobuf format,
but for compatibility with protobuf, Phaser supports full protobuf serialization.  This
is useful when storing messages in a format that is recognized by services such as
`BigQuery` where protobuf wire-format is required.

Other features include:

1. Target IDL is proto3, but proto2 is also supported
2. Message printing to std::ostream
3. Fixed and variable-sized buffers can be used
4. User-supplied metadata can be added to the message.
5. Full support for `google.protobuf.Any`
6. Enum printing and parsing
7. Message reflection
8. Presence masks
9. Bazel build
10. Modern C++17 with Google Abseil

## How Phaser works
Phaser works as a plugin for the Protocol Buffers compiler (protoc).  This means that protoc
does the parsing of the `.proto` files and hands off to Phaser to generate code.  Only
C++ output is supported.

To the programmer, the messages generated by Phaser look just like those generated by
the regular C++ protobuf backend, with a few enhancements and minor incompatibilities.  They
are generated as C++ classes with accessor functions for each field - with the same names
as those generated by protobuf. 

However, while protobuf creates a tree of allocated objects holding the message data, Phaser's
message classes do not store the actual field values directly, but rather the values are
stored in a separate buffer, directly in the wire-format.  The `source` messages (the C++
classes that the programmer sees) merely store information about where the actual data
is stored in the `binary` message held in the buffer.

So, when you set a field using the `set_` function, the data is placed in the `binary`
buffer using information held in the `source` class.  This makes the source classes very
lightweight, containing just metadata about the binary message.

When you read a field from a source class, the data is read from the binary message.  However,
this is not done directly since the binary message may be a different version from that
doing the reading (fields may be been added or changed).  Therefore, reading a field results
in the use of `field metadata` that is held in a small array inside the binary message.  This
allows the software to use newer or older version of messages, one of the mainstays of
protobuf's popularity.

## What's wrong with serialization?
It all depends on what you doing with the messages and what the messages look like.  For small
workloads it is perfectly fine to use the protobuf serialization method as the time taken
to perform the conversion to and from wire-format is negligible.  However, in some performance
critical applications (like robots or AVs), messages tend to contain large sensor data streams
and the serialization time can dominate the CPU, sometimes using up to 60% of the time.  A few years
ago, Google reckoned that serialization took 30% of the CPU time in their data centers.

If you can avoid serialization, at least for the messages that matter (sensor data or other large
messages) you can save all that CPU and get much better usage out of your embedded system running
your robot.

Also, most of the time, inside a robot, you are not using different versions of software
and therefore, the version compatibility provided by serialization is not needed.  This is
especially true when you use shared memory for Interprocess Communication (IPC) where processes
can access the same physical memory directly.  Serializing it into shared memory, just to deserialize
it again in all the subscribers is just a waste of valuable compute cycles.

Another problem with serialization, or more accurately, deserialization is that unless you
are going to process all the messages you receive, you will be spending CPU cycles on
unnecessary work.  Many robotics applications don't process all of the messages they
receive over IPC and only take the most recent.  Any messages that are deserialized
and thrown away is wasted time.

## Zero-copy FTW
All programs that use protobuf operate in the same way: you create your messages in objects
allocated from the heap (or from an arena if you need it to go slightly faster), then you
serialize them into a buffer and send that buffer onward.  Creating your messages involves
calling setter functions to set the values.  Adding values to repeated fields involved pushing
them into a vector.  Creating message-valued fields involves allocating a new object and
setting its values.

This is all good, and serializing small messages is no biggie, but what if your message
contains a large repeated field of floating point numbers (think of a LIDAR scan) or a large
buffer (bytes field in protobuf parlance) containing an RGB camera image?  Your program will
spend a long time copying the values into place, then it will copy them again during your
serialization step.

With zero-copy, you have a facility that allows you to directly access the final location
for the data.  If you change your algorithm to take advantage of this direct access, you
can speed up the message creation by up to an order of magnitude.  So instead of
looping over a set of floating point values, adding each to a vector, you can get a pointer
to the start of the vector's memory and write directly to it.

Another common message pattern is a repeated field of messages.  In this case you create
a new object for each element, add it to the vector and fill it in.  With zero-copy
you can add a bunch of messages at once, performing only one allocation and then
fill all of them in.  A huge saving.

And, if your robotics nodes are processing only the most recent messages, or storing
messages in a history buffer, there is no time wasted in deserializing messages that
you won't use.

## Building a Phaser library
Phaser was designed to be used with Google's `bazel` build system.  It also uses the
`Abseil` library and, of course, `protobuf`.

The system is integrated into `bazel` by defining a `Starlark` extension file that
defines a rule to build a Phaser library.  The file `phaser_library.bzl` contains the
build rules.

To build a Phaser library, you first need a `proto_libary` target that lists the
source files and dependencies for the protobuf compiler.  You then define a
`phaser_library` that has a dependency on the proto library.  This is similar to how
you would build a regular `cc_proto_library` in Bazel.

For example, here's how you would build a `phaser_library` for a proto library
containing `Foo.proto`:

```
load("@phaser//phaser:phaser_library.bzl", "phaser_library")

proto_library(
    name = "foo_proto",
    srcs = [
        "Foo.proto",
    ],
)

phaser_library(
    name = "foo_phaser",
    add_namespace = "phaser",
    deps = [":foo_proto"],
)
```

You can get the Phaser code from github by adding this to your WORKSPACE file, changing the
version numbers and hash as appropriate.

```
http_archive(
  name = "phaser",
  urls = ["https://github.com/dallison/phaser/archive/refs/tags/1.0.0.tar.gz"],
  strip_prefix = "phaser-1.0.0",
  sha256 = "086601a2915e4fdfce8d9ff1a6f765c460f582d739cb954c9a2f5bf4c0fa17f3"
)

```

The result will be a couple of files: `Foo.phaser.h` and `Foo.phaser.cc`.  The names of the message
classes will have the namespace `phaser` added to them to distinguish them from regular protobuf
messages (this is optional).  If `Foo.proto` is in the package `foo.bar`, the class names will be in the
namespace `::foo::bar::phaser`.

If you want to use a different build system, you will need to make all the things that Phaser needs
available somehow and run the `protoc` command yourself (Abseil, libprotobuf, etc).  
Phaser runs as a protoc plugin.  To run it use the following command format:

```
$ protoc --plugin=protoc-gen-phaser=DIR/bin/phaser/compiler/phaser \
    --phaser_out=add_namespace=NS,package_name=PACKAGE,target_name=TARGET:OUTPUT_DIR \
    -I IPATH...
    FILE ...
```
You need to specify:

1. DIR: the directory containing the `phaser` plugin binary
2. NS: optionally the namespace to add
3. PACKAGE: the name of the package you want to build.  This is the root of the output directory
4. TARGET: the name of the target being built.
5. OUTPUT_DIR: the root of the output directory
6. IPATH: import path (use one -I for each)

If you want to see all the options to `protoc`, run `protoc --help`.

The output will be placed in the path `OUTPUT_DIR/PACKAGE/TARGET`.

For example, if you build the test `phaser_test` using the following command (on a Mac with Apple Silicon):

```
$ bazel build --config=apple_silicon //phaser:phaser_test -c dbg
```

the `TestMessage` output files will be:

```
bazel-out/darwin_arm64-dbg/bin/phaser/testdata/test_message_phaser/phaser/testdata/TestMessage.phaser.h
bazel-out/darwin_arm64-dbg/bin/phaser/testdata/test_message_phaser/phaser/testdata/TestMessage.phaser.cc
```

There is also a symbolic link to the header file created in:

```
bazel-out/darwin_arm64-dbg/bin/phaser/testdata/TestMessage.phaser.h
```

To allow you to omit the longer path when including the header file.  For example, to include
`TestMessage.phaser.h` you use:

```c++
#include "phaser/testdata/TestMessage.phaser.h"
```

Just like you would in regular protobuf.

The actual command used by Bazel to build the Phaser files is:

```
(cd /private/var/tmp/_bazel_dallison/c60267365ec0ecff0968b479358562f7/execroot/__main__ && \
  exec env - \
  bazel-out/darwin_arm64-opt-exec-2B5CBBC6/bin/external/com_google_protobuf/protoc '--plugin=protoc-gen-phaser=bazel-out/darwin_arm64-opt-exec-2B5CBBC6/bin/phaser/compiler/phaser' '--phaser_out=add_namespace=phaser,package_name=phaser/testdata,target_name=test_message_phaser:bazel-out/darwin_arm64-dbg/bin' phaser/testdata/TestMessage.proto bazel-out/darwin_arm64-dbg/bin/external/com_google_protobuf/_virtual_imports/any_proto/google/protobuf/any.proto -Ibazel-out/darwin_arm64-dbg/bin/external/com_google_protobuf/_virtual_imports/any_proto -I.)
```

I haven't done this with `cmake` or any other build system but I guess it will be reasonably easy.

## Creating a message
In protobuf, you generally create messages on the local stack frame or from the heap. 
Submessages (fields whose type is a message) are allocated from the heap.

In Phaser, it's almost the same except you have to be aware of where the final
location for the data will reside.  It can be in a fixed size buffer allocated from
the heap or from an IPC system.  It can also be in a variable sized buffer allocated
from the heap.  The data stored in the buffer is referred to as the `binary` message.
The C++ class that represents the message is referred to as the `source` message and
can be on the local stack frame or anywhere you like.

When you build your Phaser messages, you have an option to add a C++ namespace
to the class name to distinguish it from a protobuf class of the same name.  This
allows you to intermix Phaser and protobuf messages.  Generally, this is a good
idea and I tend to choose the name "phaser" as the namespace.

### What exactly is a message?
In Phaser a message is a generated class derived from a C++ class of type `::phaser::Message`.  
This base class contains the following:

```c++
struct Message {
  Message() = default;
  Message(std::shared_ptr<MessageRuntime> rt, ::toolbelt::BufferOffset start)
      : runtime(rt), absolute_binary_offset(start) {}
  virtual ~Message() = default;

  virtual const MessageInfo *GetMessageInfo() const { return nullptr; }
  virtual std::string GetName() const { return "Message"; }
  virtual std::string GetFullName() const { return "phaser.Message"; }
  virtual void Clear() {}
  virtual void CopyFrom(const Message &src) {}

  std::shared_ptr<MessageRuntime> runtime;
  ::toolbelt::BufferOffset absolute_binary_offset;
};
```

The derived message classes contain the actual fields of the message along
with accessor functions.  It is designed to be as close to protobuf as possible
to avoid having to learn new classes if you are familiar with protobuf.

The virtual functions are overridden by the derived classes.

The member `absolute_binary_offset` is the offset of the message into 
the `PayloadBuffer` (see below).

The member `runtime` is a pointer to the following struct:

```c++
// Each message contains a std::shared_ptr to one of these, allocated from
// the heap.  This is used when creating a message in the payload buffer
// so that we know where the metadata for each message is stored.  The
// metadata offset is held in the message header.
struct MessageRuntime {
  MessageRuntime(::toolbelt::PayloadBuffer *p) : pb(p) {}
  MessageRuntime(::toolbelt::PayloadBuffer *p, size_t size)
      : pb(p), buffer_size(size) {}
  virtual ~MessageRuntime() = default;
  ::toolbelt::PayloadBuffer *pb;

  // This is the size of the buffer.  If it is zero, the size is inside
  // the payload buffer.  If it's non-zero, it's the size of the received
  // buffer.  We can't rely on the size inside the payload buffer if we
  // are looking at received data (someone could set it to anything and we
  // have no way to check it's valid).
  size_t buffer_size = 0;
};

```
The members of this are:

1. `pb`: a pointer to a `PayloadBuffer` object that holds the actual binary for the message data
2. `buffer_size`: the size of the buffer if it was received

The `PayloadBuffer` is part of my [C++ Toolbelt library](https://github.com/dallison/cpp_toolbelt) and
provides a relocatable heap (malloc/free/realloc) inside a variable or fixed buffer.  It
holds the binary values for all fields in the message in a relocatable form.  Generally,
you won't have to concern yourself about the `PayloadBuffer`.

This diagram shows the general layout of a message. 

<div>
<img src="Phaser message layout.png">
</div>


The source message is located either on the stack frame or on the heap.  It refers to a MessageRuntime
struct through a `std::shared_ptr` which contains a pointer to a `PayloadBuffer` (where the actual message
contents are stored).  If the message is **mutable** a `MutableMessageRuntime` is used instead and that also
contains a map that contains information about the location of the message's `metadata` (where the fields
are located).

### Tuning the memory allocator
The memory for the actual message contents is allocated inside the `PayloadBuffer` using a memory allocator (think malloc and free in a restricted, relocatable area of memory).  There are two modes for this memory allocator:

1. Performance mode
2. Size mode

In performance mode (the default), two types of allocators are used depending on the size of the
block being allocated:

1. A bitmap allocator for blocks up to 16, 32, 64 and 128 bytes.
2. A free-list allocator for all other block sizes

The bitmap allocator is about twice as fast when allocating memory but does use more memory
in the buffer.  This is most appropriate when you want the maximum performance out of the
allocator but are not concerned about the size of the message.  If you are putting your
messages in shared memory or somewhere where the message size isn't a concern, you can gain
performance by using the bitmap allocator.

However, if you are sending your messages over a network and want to keep them small,
the size mode might be more appropiate.  It should be noted, though, that if you are concerned
with message size, perhaps regular protobuf might be more suitable than Phaser

To choose which mode to use, you can pass a `::phaser::Tuning` argument to the message
constructor or creator.  The default is `::phaser::Tuning::kPerformance` and the other option
is `::phaser::Tuning::kSize`.

### Creating a message in a dynamic buffer.
The simplest way to create a Phaser message is the same as protobuf:

```c++
void Foo() {
  foo::bar::phaser::TestMessage msg;
  msg.set_x(1234);
  // ...
}
```

The above example creates a Phaser message of the type `TestMessage` on the local stack
frame.  The binary message will be held in a variable sized buffer allocated from the
heap.  The initial size of the buffer can be specified as an argument to the
constructor, but is optional with a default of 8192 bytes (if 8K is big enough, or twice the
required binary size if not) but will expand as necessary.


To get access to the buffer you can use the `Data()` and `ByteSizeLong()` functions, for
example:

```c++
void Foo() {
  foo::bar::phaser::TestMessage msg(4096);
  msg.set_x(1234);
  // ...
  SendMessage(msg.Data(), msg.ByteSizeLong());
}
```

You can also tell it which buffer mode to use using a second parameter.  For example, to tune
for size with a 4K buffer:

```c++
void Foo() {
  foo::bar::phaser::TestMessage msg(4096, ::phaser::Tuning::kSize);
  msg.set_x(1234);
  // ...
}
```

For completeness, the default constructor for a message (for one on the stack) can also
be achieved using the function `CreateDynamicMutable`, which also allows you to
specify the initial buffer size (with a 1K default) to be allocated for the binary message from the
heap:

```c++
void Foo() {
  auto msg = foo::bar::phaser::TestMessage::CreateDynamicMutable(4096);
  msg.set_x(1234);
  // ...
}
```
Tuning is also provided here too.

### Creating a message in a provided buffer.
If you are using an IPC system that provides shared memory buffers (like [Subspace](https://github.com/dallison/subspace)) you will want to create your message directly in the shared memory.  To do this, use the
static function `CreateMutable`, as follows:

```c++
void Foo(char* buffer, size_t size) {
  auto msg = foo::bar::phaser::TestMessage::CreateMutable(buffer, size);
  msg.set_x(1234);
  // ...
}
```

You can choose the buffer mode by providing a tuning parameter:

```c++
void Foo(char* buffer, size_t size) {
  auto msg = foo::bar::phaser::TestMessage::CreateMutable(buffer, size, ::phaser::Tuning::kSize);
  msg.set_x(1234);
  // ...
}
```

As before, the `Data()` and `ByteSizeLong()` functions are available to get the buffer (although you
probably already know the buffer's address).

If the buffer is fixed size and you attempt to write beyond the end of the buffer, the
program will abort to prevent memory overwrites.

It is also possible to provide a resize function to allow an IPC buffer to be resized
but this is outside of the scope of this discussion at this time as it depends a lot
on the abilities of the IPC system.

### Message received from elsewhere
The whole purpose of sending messages is to receive them in another location.  When you receive
a message you will generally get it in a read-only buffer.  To gain access to the received message
call the function `CreateReadonly`:

```c++
void Receive(const char* buffer, size_t buffer_size) {
  auto msg = foo::bar::phaser::TestMessage::CreateReadonly(buffer, size);
  int x = msg.x();
  // ...
}
```

The runtime access to fields in the message validates that nothing can go outside
of the buffer you pass to `CreateReadonly`.


## Setting and getting fields
Creating a message usually involves setting the values in its fields, and using one
will generally involve reading them.  The C++ class for a message is generated with 
setter and getter functions for each field, just like protobuf. 

## Primitive fields
For primitive fields, like an `int32` field, the following functions are generated:

```c++
  int32_t x() const;
  bool has_x() const;
  void clear_x();
  void set_x(int32_t value);
```

For a field that holds a message, different functions are generated.  For example,
if a field holds a message type `InnerMessage`, the following function exist:

```c++
  void clear_m();
  const InnerMessage& m() const;
  bool has_m() const ;
  InnerMessage* mutable_m();
```

String (and bytes) fields are similar except there is a special `allocate_`
function that allows you to allocate space in the binary message and obtain
its address.  This is to provide a way to get access to the underlying
buffer directly and can be used to speed everything up.  For example,
for a string field called `s` we have the following functions:

```c++
  std::string_view s() const;
  bool has_s() const;
  void clear_s();
  template <typename Str>
  void set_s(Str value);
  absl::Span<char> allocate_s(size_t len);
```

### Repeated fields
Repeated fields are implemented as
contiguous vectors.  In addition to the regular protobuf accessors, additional
functions are generated to take advantage of the fact that you have access to
the final location of the data.  For a repeated int32 field (called `vi32`), we have the
following functions:

```c++
  int32_t vi32(size_t index) const;
  size_t vi32_size() const;
  void clear_vi32();
  void reserve_vi32(size_t num);
  void resize_vi32(size_t num);
  void add_vi32(int32_t value);
  void set_vi32(size_t index, int32_t value);
  absl::Span<int32_t> vi32_as_mutable_span();
  absl::Span<const int32_t> vi32_as_span() const;
  const ::phaser::PrimitiveVectorField<int32_t, false, false, true>& vi32() const;
```

Some of these are the same as protobuf but others, like `resize_vi32`, `reserve_vi32`
and the `as_span` functions are specific to Phaser and allow you to access the
underlying binary buffer.

The `PrimitiveVectorField` class is similar to protobuf's `RepeatedField` class and will
be discussed in a later section.

Repeated string fields are pretty obvious:

```c++
  std::string_view vstr(size_t index) const;
  size_t vstr_size() const;
  void clear_vstr();
  void reserve_vstr(size_t num);
  void resize_vstr(size_t num);
  template <typename Str>
  void add_vstr(Str value);
  template <typename Str>
  void set_vstr(size_t index, Str value);
  const ::phaser::StringVectorField& vstr() const;
```

Repeated message fields are also as expected.  For a repeated `InnerMessage`
field:

```c++
  size_t vm_size() const;
  void clear_vm();
  const InnerMessage& vm(size_t index) const;
  InnerMessage* mutable_vm(size_t index);
  InnerMessage* add_vm();
  const ::phaser::MessageVectorField<InnerMessage>& vm() const;
  void reserve_vm(size_t num);
  void resize_vm(size_t num);
  std::vector<InnerMessage*> allocate_vm(size_t n);
```

The `resize` and `reserve` functions operate similarly to `std::vector`.  The
`allocate` function allocates `n` messages in a block and provides pointers
to the source messages allocated.  This is a performance enhancement to allow
faster creation of a common pattern in protobuf message.

### Oneof fields
A `oneof` field is a discriminated union that holds only one of a number of
fields at any time (or none of them I guess).  For example, to define
a `oneof` inside a message, you do this:

```pb
message Foo {
  int32 x = 1;
  oneof request {
    InitRequest init = 2;
    TermRequest term = 3;
  }
}
```

This defines a union called `request` that can have either `init` or `term`, both
of which are message types.  Like protobuf, Phaser generates each of the fields
exactly as if they are outside of the `oneof`, and also provides a function to
determine the discriminator:

```c++
  int request_case() const;
```

The `_case` function returns the `number` of the field that is present in the
`oneof`, or 0 if none are present.


### Any fields
The `proto3` Protocol Buffers IDL variant provides a type called `google.protobuf.Any` that
can be used to hold any message type.  This is kind of like a `void*` in C with a string
that tells you what type it is.  Take a gander at [this](https://protobuf.dev/programming-guides/proto3/#any) for
details on how it works.

Phaser supports the `google.protobuf.Any` type slightly differently from the
way regular protobuf does.  Since Phaser is zero-copy, the `value` field of the
`google.protobuf.Any` message doesn't contain a serialized message, but rather contains
an actual binary message.  You don't need to call the `PackFrom` and `UnpackTo` functions
to access it, but instead you have direct access to it.  `PackFrom` and `UnpackTo` are
provided but result in copies of the message being made, rather than serializing and
deserializing the message.

The facilities provided for `Any` support are:

```c++
  template <typename T> bool PackFrom(const T &msg);
  template <typename T> absl::Status PackFromOrStatus(const T &msg);
  template <typename T> bool UnpackTo(T *msg) const;
  template <typename T> absl::Status UnpackToOrStatus(T *msg) const;
  template <typename T> bool Is() const;
  template <typename T> const T As() const;
  template <typename T> T MutableAny();
```

The `...OrStatus` functions are provided to allow you to get more information than
a simple `bool` can provide if things go wrong.  

#### Incompatibilty with protobuf
There is a slight (and annoying) incompatibilty with protobuf in the Phaser's implementation
of Any.  In protobuf, the type of an Any field is `google::protobuf::Any`, that is a regular
protobuf generated message with some extra functions added to it.  In Phaser, there is
a special message type called `::phaser::AnyMessage` that provides the equivalent
functionality.  This is necessary to avoid a runtime dependency on the `google.protobuf.Any`
type.

The outcome of this is that if you explicitly refer to `google::protobuf::Any` in your code
you will get compilation errors.  If you use `auto`, it will all be OK.


#### Packing and unpacking Any
You should use the `Is` template function to check what type is in the `value` field.

`PackFrom` performs a copy of the input message into the `value` field of the `Any` field, and 
sets the `type_url` field to the message type.  The type URL always has the prefix `type.googleapis.com/`.

`UnpackTo` also performs a copy of the message into its argument.

#### Direct access
Since there is no serialization in Phaser, you can get direct access to the message stored
in the `value` field.  The `As` template gives you a const message that can be accessed
directly.  It does not check that the message is of the given type, so make sure to call
`Is` before.

The `MutableAny` function creates a mutable message of type `T` in the `value` field and sets
the `type_url`.  You can then create the message as you would do normally.

## Serialization and deserialization
Phaser doesn't do serialization, but protobuf does.  In order to give you a way to convert
from Phaser wire-format to protobuf, some transcoding serialization functions are provided.
These are:

```c++
  size_t SerializedSize() const;
  bool SerializeToArray(char* array, size_t size) const;
  bool ParseFromArray(const char* array, size_t size);
  bool SerializeToString(std::string* str) const;
  std::string SerializeAsString() const;
  bool ParseFromString(const std::string& str);

```
The `ByteSizeLong` and `ByteSize` functions do not return the length of the serialized
data in Phaser but instead return the length of the zero-copy data.  In you want the length
of the serialized data, use `SerializedSize` (this is a badly named function in protobuf as it
doesn't say what it is measuring).

If you familiar with protobuf, you will recognize these and similar to those
provided by the regular protobuf messages.  Protobuf provides others (like
`ZeroCopyStream`) but those aren't provided by Phaser.

## Cloning and copying
Like protobuf, Phaser provides a `CopyFrom` method to copy messages.

## The Phaser Bank
A significant feature that is missing from protobuf implementations (that I
am aware of anyway) is the ability to do things with messages given only their
message type name.  Most people end up creating a database of type name versus
message descriptor and use reflection to handle this.

Phaser has a built-in feature called the `Phaser Bank`, which, as its name suggest
is a bank of Phaser messages, indexed by message name.  This allows you to manipulate
Phaser messages if you just know the message name and nothing else.  The ultimate in
type-erasure.

The functions provided by the the `PhaserBank` are all free functions in the `::phaser`
namespace and are:

```c++
absl::StatusOr<BankInfo *> GetPhaserBankInfo(std::string message_type);

void PhaserBankRegisterMessage(const std::string &name, const BankInfo &info);

absl::Status PhaserStreamTo(const std::string &message_type, const Message &msg,
                            std::ostream &os, int indent);
absl::StatusOr<std::string>
PhaserBankDebugString(const std::string &message_type, const Message &msg);

absl::Status PhaserBankSerializeToBuffer(const std::string &message_type,
                                         const Message &msg,
                                         ProtoBuffer &buffer);
absl::Status PhaserBankDeserializeFromBuffer(const std::string &message_type,
                                             Message &msg, ProtoBuffer &buffer);
absl::StatusOr<size_t> PhaserBankSerializedSize(const std::string &message_type,
                                                const Message &msg);

absl::StatusOr<Message *>
PhaserBankAllocateAtOffset(const std::string &message_type,
                           std::shared_ptr<::phaser::MessageRuntime> runtime,
                           toolbelt::BufferOffset offset);

template <typename T>
absl::StatusOr<std::pair<T *, toolbelt::BufferOffset>>
PhaserBankAllocate(const std::string &message_type,
                   std::shared_ptr<::phaser::MessageRuntime> runtime);

template <>
absl::StatusOr<std::pair<Message *, toolbelt::BufferOffset>>
PhaserBankAllocate(const std::string &message_type,
                   std::shared_ptr<::phaser::MessageRuntime> runtime);              

absl::Status PhaserBankClear(const std::string &message_type, Message &msg);

absl::Status PhaserBankCopy(const std::string &message_type, const Message &src,
                            Message &dst);

absl::StatusOr<const Message *>
PhaserBankMakeExisting(const std::string &message_type,
                       std::shared_ptr<::phaser::MessageRuntime> runtime,
                       const void *data);

absl::StatusOr<size_t> PhaserBankBinarySize(const std::string &message_type);

absl::StatusOr<const MessageInfo *>
PhaserBankMessageInfo(const std::string &message_type);

absl::StatusOr<bool> PhaserBankHasField(const std::string &message_type,
                                        const Message &msg, int number);

template <typename Field>
absl::StatusOr<Field *>
PhaserBankGetFieldByName(const std::string &message_type, Message &msg,
                         const std::string &name);

template <typename Field>
absl::StatusOr<Field *>
PhaserBankGetFieldByNumber(const std::string &message_type, Message &msg,
                           int number);
```

All the functions take the message type name and return an Abseil Status or
StatusOr.

For this to work, the Phaser message library for the message must be linked
into the executable as the PhaserBank is built by static initializers.

### Getting the information for a message given its name
The `GetPhaserBankInfo` function looks up the information for a message.  This gives
access to the `BankInfo` object for the message.  The `BankInfo` is like this:

```c++
struct BankInfo {
  void (*stream_to)(const Message &msg, std::ostream &os, int indent);
  absl::Status (*serialize_to_buffer)(const Message &msg, ProtoBuffer &buffer);
  absl::Status (*deserialize_from_buffer)(Message &msg, ProtoBuffer &buffer);
  size_t (*serialized_size)(const Message &msg);
  Message *(*allocate_at_offset)(
      std::shared_ptr<::phaser::MessageRuntime> runtime,
      toolbelt::BufferOffset offset);
  std::pair<Message *, toolbelt::BufferOffset> (*allocate)(
      std::shared_ptr<::phaser::MessageRuntime> runtime);
  void (*clear)(Message &msg);
  absl::Status (*copy)(const Message &src, Message &dst);
  const Message *(*make_existing)(
      std::shared_ptr<::phaser::MessageRuntime> runtime, const void *data);
  size_t (*binary_size)();
  const MessageInfo *(*message_info)();
  bool (*has_field)(const Message &msg, int number);
  void *(*get_field_by_name)(Message &msg, const std::string &name);
  void *(*get_field_by_number)(Message &msg, int number);
};
```

The function pointers are populated for each of the messages generated by Phaser and as
long as the message library is linked in, it will be available.

You can also use the `PhaserBankMessageInfo` function to get reflection data for the message.  I'll
describe this in the section on message reflection.

### Protobuf transcoding
You can serialize and deserialize Phaser messages to and from protobuf wireformat using the 
`PhaserBankSerializeToBuffer`, `PhaserBankDeserializeFromBuffer` and `PhaserBankSerializedSize`
functions.  The serialization and deserialization use a class called `::phaser::ProtoBuffer`
to hold the binary data.  This is defined in the file `phaser/runtime/wireformat.h` and provides
a dynamically (or statically) sized byte buffer.  It's pretty easy to follow.

### Streaming and DebugString
You can stream a message to `std::ostream` using the `PhaserStreamTo` function.  If you want this
in a string there's the `PhaserBankDebugString` function to do that for you.

### Allocating messages
To allocate a new mutable message in a previously allocated binary buffer, you can call
`PhaserBankAllocate`.  This takes a message type name and a pointer to the `MessageRuntime`
class that is part of every message.  There is a general template that can be used when
you know the message type, and a specialized template for when you just want a pointer
to the `Message` base class.  The result is a pair containing a pointer to the source
message (allocated using new) and the absolute offset into the buffer of the location
of the binary message.

For example, to set the field `m` of a message to one allocated from PhaserBank:

```c++
  TestMessage msg;
  auto status =
      ::phaser::PhaserBankAllocate<InnerMessage>("foo.bar.InnerMessage", msg.runtime);
  // Check status here.
  auto[inner, offset] = *status;
  msg.set_m(offset);
  inner->set_str("Inner message");
```

There is also a very specialized function `PhaserBankAllocateAtOffset` that is used by the
`google.protobuf.Any` handler to set the message in the Any's `value` field.

If you want to allocate a message from existing data, such as data received over
the network, you can use `PhaserBankMakeExisting`.  This is pretty specialized and
is used by the Any handler.

### Clearing and copying
The functions `PhaserBankClear` and `PhaserBankCopy` allow you to clear the contents of
a message or copy it to another message.

### Reflection
PhaserBank allows you to examine the contents of messages without knowing the message
type.  You can:

1. See if a field is present in the message
2. Look up a field in a message by number or name

The result of looking up a field is an instance of an internal field class.  In order
to use these, please see the files `runtime/fields.h`, `runtime/union.h` and `runtime/vectors.h`.
It's beyond the scope of this user guide to explain these, but I will provide further
documentation to cover them.

However, as an example, here's how to access an int32 field called `x` with number 100.

```c++
  absl::StatusOr<bool> has_x =
      ::phaser::PhaserBankHasField("foo.bar.TestMessage", msg, 100);

  absl::StatusOr<::phaser::Int32Field<> *> x =
      ::phaser::PhaserBankGetFieldByNumber<::phaser::Int32Field<>>(
          "foo.bar.TestMessage", msg, 100);
  int x_value = (*x)->Get();
```

The class `phaser:;Int32Field` is in `runtime/fields.h`.

To access a repeated field:

```c++
 auto vi32 = ::phaser::PhaserBankGetFieldByNumber<
      ::phaser::PrimitiveVectorField<int32_t>>("foo.bar.TestMessage", msg, 104);
```

## Message information
Protobuf provides various types describing the details of a message.  These are known
as `Descriptors`.  Phaser provides similar data structures.  There are both a static
and a virtual function to get the message information from a message:

1. `GetMessageInfo()` - virtual function on `::phaser::Message`
2. `GetMessageInfoStatic` - static function generated by the compiler for the actual message

The result is a const pointer to `::phaser::MessageInfo`.  This is a class that contains
maps for all the fields in the message.  It is defined in `runtime/message.h` as:

```c++
struct MessageInfo {
  std::string full_name;
  absl::flat_hash_map<std::string, std::shared_ptr<FieldInfo>> fields_by_name;
  absl::flat_hash_map<int, std::shared_ptr<FieldInfo>> fields_by_number;
  std::vector<std::shared_ptr<FieldInfo>> fields_in_order;
};
```
The members are:

1. `full_name`: the full name (with package) of the message
2. `fields_by_name`: a map of field name vs field information
3. `fields_by_number`: mapping of field number vs information
4. `fields_in_order`: all the fields in the message in the order declared in the .proto file

The field information is a base class and two derived classes.  The base class is:

```c++
enum class FieldType {
  kFieldInt32,
  kFieldInt64,
  kFieldUInt32,
  kFieldUInt64,
  kFieldString,
  kFieldMessage,
  kFieldBytes,
  kFieldFloat,
  kFieldDouble,
  kFieldBool,
  kFieldEnum,
  kFieldOneof,
};

struct FieldInfo {
  FieldInfo(const std::string &n, FieldType t, int num, off_t off)
      : name(n), type(t), number(num), offset(off) {}
  std::string name;
  FieldType type;
  int number;
  off_t offset; // Offset into source message (not binary).
};

```

There is a derived class for all primitive fields (non-oneof fields):

```c++
struct PrimitiveFieldInfo : public FieldInfo {
  PrimitiveFieldInfo(const std::string &n, FieldType t, int num, off_t off,
                     bool f = false, bool s = false, bool r = false,
                     bool p = false)
      : FieldInfo(n, t, num, off), is_fixed(f), is_repeated(r), is_packed(p) {}
  PrimitiveFieldInfo(const std::string &n, FieldType t, int num, off_t off,
                     const std::string &m, bool r = false, bool p = false)
      : FieldInfo(n, t, num, off), is_repeated(r), is_packed(p),
        message_or_enum_name(m) {}

  bool is_fixed = false;
  bool is_signed = false;
  bool is_repeated = false;
  bool is_packed = true;
  std::optional<std::string> message_or_enum_name;
};
```

This is used for both singular and repeated fields.

For `oneof` fields, a derived class describes the set of fields within the
discriminated union:

```c++
struct UnionFieldInfo : public PrimitiveFieldInfo {
  UnionFieldInfo(const std::string &n, FieldType t, int num, off_t off, int i,
                 const std::string &m)
      : PrimitiveFieldInfo(n, t, num, off, m), id(i) {}
  UnionFieldInfo(const std::string &n, FieldType t, int num, off_t off, int i,
                 bool f = false, bool s = false)
      : PrimitiveFieldInfo(n, t, num, off, f, s), id(i) {}
  int id; // Field id within union.
};

struct UnionInfo : public FieldInfo {
  UnionInfo(const std::string &n, off_t off)
      : FieldInfo(n, FieldType::kFieldOneof, 0, off) {}
  std::vector<std::shared_ptr<UnionFieldInfo>> fields_in_order;
};

```

The union field (a.k.a. oneof) has a vector of `UnionFieldInfo` objects, each of which
is a primitive field.  Oneofs can't have repeated fields.  The `id` member of
`UnionFieldInfo` is a zero-based number representing the position in the `fields_in_order`
vector and is used to select the index into the `std::tuple` held in the internal
union field in a message (I'll show how to use this in a details document).


## The Payload Buffer
Whereas the source message is what the user's program interacts with, the location
of the actual message field values is stored in a [PayloadBuffer](https://github.com/dallison/cpp_toolbelt/toolbelt/payload_buffer.h).

This is C++ class that provides a heap inside a relocatable buffer.  The buffer's memory
can be either provided by the user or allocated by Phaser.  If it is allocated
by Phaser, it is variable in size.  If it is allocated by the user it is generally
fixed size (in shared memory for example), but a resizer can be provided to change
the size.

The `PayloadBuffer` works by creating a simple malloc/free data structure inside the
memory provided.  It is not a standard heap management system though because 
of the requirement that it can't use any virtual addresses (pointers).

There are two types of allocators in the `PayloadBuffer`, the choice of which
to use being based on the block being allocated.  If the block is small
a `bitmap allocator` is used to speed up the allocation.  The definition of
a small block is one whose size is less than 16, 32, 64 or 128 bytes.  There
are 4 bitmap allocators, one for each of those block sizes.  Bitmap
allocators are fast but use more memory because they allocate a set of
fixed size blocks up front and keep track of them using a bit mask.  This uses
more memory than a simple free-list allocator.

The second type of allocator is used for all other block sizes above
128 bytes and is a simple free-list based allocator.  The bitmap allocator
prevents heap fragmentation by using fixed size blocks, but with the free-list
allocator, fragmentation is always possible.

You can switch the bitmap allocator off when creating the `PayloadBuffer` using
its constructor.  This parameter is controlled by Phaser's `Tuning` message
construction argument.


### PayloadBuffer header
The start of every PayloadBuffer contains a header, shown in the following diagram:


<div>
<img src="PayloadBuffer header.png"/>
</div>

Each member is 4-bytes long.  The first member is the `magic` which is either:

1. toolbelt::kFixedBufferMagic
2. toolbelt::kMovableBufferMagic

This serves to identify the buffer as a PayloadBuffer and also whether it is
movable or fixed.  Movable buffers are only moved when creating the message, however
all buffers are relocatable in memory.

The bottom bit of the magic field is used to specify whether the `bitmap allocator`
is on or off (0 = off).

The next member, `message` contains the offset to the root of the message tree
in the buffer - the top level message.

Then we have the `hwm` or high water mark which specifies the current size of the
data allocated in the buffer, and thus the size of the memory that needs to be
sent to a receiver.

This is followed by the current full size of the buffer, which can change if the
buffer is resized.  If you try to allocate too much memory in a fixed size buffer
the program will abort to prevent memory overwrites.

Then we have the offset to the first free block in the buffer.  Each free block consists
of a header followed by some free bytes.  The header is a struct:

```c++
struct FreeBlockHeader {
  uint32_t length;   // Length of the free block, including the header.
  BufferOffset next; // Absolute offset into buffer for next free block.
};
```

The memory in the buffer is organized as an ordered linked list of free blocks, interspersed
by allocated blocks.  An allocated block is always prefixed by a 4-byte length, which does not
include the length field itself.  The allocator does its best to keep the free list as short as 
possible to coalescing adjacent free blocks and expanding into blocks if possible.

Then we have a user-supplied offset to arbitrary `metadata`.  This is not used by
Phaser, but can be provided by the user to make additional data available as necessary.
For example, it could be set to the name of the message, or some other descriptor
that can be used by a receiver.

There are functions available in the `::phaser::Message` class to allocate, free and set the
metadata field as needed.

Finally we have 4 offsets for the 4 bitmap run vectors.  Each offset corresponds to a bitmap run for a
particular size (16, 32, 64 or 128 bytes).  The bitmap runs are held in a vector of offsets to
`BitMapRun` structs that grows as needed.  Each `BitMapRun` struct holds a bitmask showing
which blocks are allocated, meta information about the run and the blocks themselves, each
of which is prefixed by a 4 byte header.  If a block is allocated in a run, its corresponding bit in the
bitmask is set to 1.

This is shown in the following diagram, for a 32 byte run.

<div>
<img src="Bitmap run.png"/>
</div>

The binary version of a message can be seen in the following diagram:

<div>
<img src="Phaser binary message.png"/>
</div>

The first 4 bytes of a message contains the offset to the message's `metadata`.  This is
a fixed size array of field information specifying, for each field, where that field
is located (offset from the start of the PayloadBuffer) and its id.  The field id
is used as the a bit number for the `presence mask` which is located immediately
after the metadata in the message.  The presence mask has a bit position for every
primitive field and may not be present if there are no primitive fields.  The purpose
of the metadata is to allow a message reader to locate the field in received
data.  The message might have been created by a different version of the software
and field locations might have changed or fields added or removed.

The rest of the message consists of the fixed size portion of the message.  This
has space for every field in the message.  Primitive fields (like int32, double, etc.)
occupy space that is sized and aligned appropriately for the type.  Variable sized
fields (strings, bytes, messages and repeated fields) consist of a header that
refers to another location in the PayloadBuffer that contains the actual contents
of the field.

### Strings and bytes
These fields have a 4-byte header containing the offset (relative to the
start of the PayloadBuffer) of the string (or bytes) data.  The data consists
of a 4-byte length followed immediately by the actual string contents.  Strings
are not zero-terminated.  If the header contains the value 0, the string field
is not present.

### Message fields
These have a header that contains the offset (relative to the PayloadBuffer) of another
message, which is in the format described here.  Like strings, a value of 0 means
that the field is not present.

### Repeated fields (vectors)
The header for these is 8-bytes long and contains:

1. The number of elements in the repeated field
2. The offset (relative to the PayloadBuffer) of the contiguous memory for the fields

The data for the vector is held contiguously in memory and can be moved if the
vector is expanded.  The contents of the memory depends on the type of the
repeated field.  The `capacity` of the vector (the amount of memory allocated) is
held immediately before the data and says how many bytes are allocated, not elements as
in the header (this is because it's just the size of the block allocated by
the allocator).

### Buffer expansion
The intention of zero-copy systems like Phaser is to allow you to create messages
directly in destination memory (like a Subspace IPC buffer).  This will allow very
high performance messaging.  However, if you just want to use the regular protobuf
algorithms, Phaser provides an expandable PayloadBuffer that grows as necessary 
to accommodate the message.  This is useful if you are creating messages that will
be sent over a network and there is still an advantage of zero-copy since you
eliminate serialization.

If you create a message that uses the default constructor, Phaser will allocate
a PayloadBuffer from the heap and provide an internal resize function that will
reallocate the buffer if you try to allocate more memory than is available.  This
will likely move the PayloadBuffer in the heap (it uses realloc).  Phaser will
take care of any buffer moves internally, but if you are calling `Allocate` to
allocate any memory yourself (for metadata perhaps), you need to be aware that
any pointers you retain from before the allocation might not be valid after
the reallocation if the buffer moves.  It's best to convert them to offsets
as those are always valid.
